#### springboot 

#### nginx做https请求转发到http,后端无法正确获取到https协议,Nginx+Tomcat正确获取客户端请求地址

1. nginx配置

   ```nginx
   server {
     listen 8088 ssl;
     server_name cs.qyjbo.cn;
     client_max_body_size 100m;
     ssl_certificate /home/cert/cs.qyjbo.cn_sslkey/4120041_cs.qyjbo.cn.pem;
     ssl_certificate_key /home/cert/cs.qyjbo.cn_sslkey/4120041_cs.qyjbo.cn.key;
     ssl_session_timeout 5m;
     ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
     ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
     ssl_prefer_server_ciphers on;
     error_page 497 https://$host:8088$uri;
     location / {
       proxy_pass http://localhost:8090; 
       proxy_redirect http:// https://; 
       add_header Cache-Control    no-store;
       #获取正确的IP和端口号
       proxy_set_header Host $host:$server_port; 
       #获取正确请求的远程IP
       proxy_set_header X-Real-IP remote_addr;
       #获取正确的ip
       proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
       #获取正确的请求协议
       proxy_set_header X-Forwarded-Proto $scheme;
       #获取正确的访问端口号
       proxy_set_header X-Forwarded-Port $server_port;
    }
   }
   ```

2. springboot配置

   老版本

   ```yaml
   server
   	tomcat
   		remote_ip_header: x-forwarded-for
   		protocol_header: x-forwarded-proto
   		port-header: X-Forwarded-Port
   	use-forward-headers: true
   ```

   

   新版本

   ```
   server.forward-headers-strategy=FRAMEWORK/NATIVE
   ```

   ### FRAMEWORK

   `FRAMEWORK`使用Spring's支持来处理转发的头。例如，Spring Boot在`server.forward-headers-strategy=framework`时自动为Spring MVC创建一个`ForwardedHeaderFilter`bean。

   ````java
   @Bean
   @ConditionalOnMissingFilterBean(ForwardedHeaderFilter.class)
   @ConditionalOnProperty(value = "server.forward-headers-strategy", havingValue = "framework")
   public FilterRegistrationBean<ForwardedHeaderFilter> forwardedHeaderFilter() {
       ForwardedHeaderFilter filter = new ForwardedHeaderFilter();
       FilterRegistrationBean<ForwardedHeaderFilter> registration = new FilterRegistrationBean<>(filter);
       registration.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ASYNC, DispatcherType.ERROR);
       registration.setOrder(Ordered.HIGHEST_PRECEDENCE);
       return registration;
   }
   ````

   `ForwardedHeaderFilter` handles non-standard headers `X-Forwarded-Host`, `X-Forwarded-Port`, `X-Forwarded-Proto`, `X-Forwarded-Ssl`, and `X-Forwarded-Prefix`.

   ### NATIVE

   NATIVE`使用底层容器对转发头的本机支持。底层容器表示tomcat、jetty、netty等。例如，嵌入的tomcat由Spring Boot处理non-standard头`X-Forwarded-Host`、`X-Forwarded-Port`、`X-Forwarded-Proto`、`X-Forwarded-Ssl`，但不是`X-Forwarded-Prefix`。

   #### X-Forwarded-Prefix

   例如，API网关在`localhost:8080`上运行，API服务`sga-booking`在`localhost:20000`上运行。API网关路由`/sga-booking`被转发到API服务`sga-booking`。对`localhost:8080/sga-booking`的请求包含标头：

   ```
   forwarded = proto=http;host="localhost:8080";for="0:0:0:0:0:0:0:1%0:46706"
   x-forwarded-for = 0:0:0:0:0:0:0:1%0
   x-forwarded-proto = http
   x-forwarded-prefix = /sga-booking
   x-forwarded-port = 8080
   x-forwarded-host = localhost:8080
   host = 192.168.31.200:20000
   ```

   当`ForwardedHeaderFilter`处理包括`X-Forwarded-Prefix`在内的转发头时，生成的链接以`localhost:8080/sga-booking`开头。如果未处理`X-Forwarded-Prefix`，则生成的链接以`localhost:8080`开头

   ## 通过Spring Boot嵌入Tomcatauto-configured

   使用属性`server.forward-headers-strategy=native`，方法`org.springframework.boot.autoconfigure.web.embedded.TomcatWebServerFactoryCustomizer#customizeRemoteIpValve`配置具有属性`server.tomcat.remoteip`（`org.springframework.boot.autoconfigure.web.ServerProperties.Tomcat.Remoteip`）的`RemoteIpValve`，以处理转发的头。注意，`X-Forwarded-Prefix`没有被处理。

   ```java
   private void customizeRemoteIpValve(ConfigurableTomcatWebServerFactory factory) {
       Remoteip remoteIpProperties = this.serverProperties.getTomcat().getRemoteip();
       String protocolHeader = remoteIpProperties.getProtocolHeader();
       String remoteIpHeader = remoteIpProperties.getRemoteIpHeader();
       if (StringUtils.hasText(protocolHeader) || StringUtils.hasText(remoteIpHeader)
           || getOrDeduceUseForwardHeaders()) {
           RemoteIpValve valve = new RemoteIpValve();
           valve.setProtocolHeader(StringUtils.hasLength(protocolHeader) ? protocolHeader : "X-Forwarded-Proto");
           if (StringUtils.hasLength(remoteIpHeader)) {
               valve.setRemoteIpHeader(remoteIpHeader);
           }
           valve.setInternalProxies(remoteIpProperties.getInternalProxies());
           try {
               // X-Forwarded-Host by default
               valve.setHostHeader(remoteIpProperties.getHostHeader());
           }
           catch (NoSuchMethodError ex) {
               // Avoid failure with war deployments to Tomcat 8.5 before 8.5.44 and
               // Tomcat 9 before 9.0.23
           }
           // X-Forwarded-Port by default
           valve.setPortHeader(remoteIpProperties.getPortHeader());
           valve.setProtocolHeaderHttpsValue(remoteIpProperties.getProtocolHeaderHttpsValue());
           factory.addEngineValves(valve);
       }
   }
   ```

   

